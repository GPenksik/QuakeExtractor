// using System;
// using System.Collections;
// using System.Collections.Generic;
// using UnityEngine;
// using System.IO;
// using System.Text;

// namespace TestScripts
// {
//     public static class BspRaw : MonoBehaviour
//     {

//         public byte[] = bsp;

        

//         public class models() {

//             public int this[int i]
//             {
//                 // Return a pointer offset to start of that model
//                 // Needs offset to models in 
//             }

//         }

//         [System.Serializable]
//         public struct model_t
//         {
//             public boundbox_t bound;
//             public Vector3 origin;
//             [HideInInspector]
//             public int node_id0_bsp;
//             [HideInInspector]
//             public int node_id1_clip1, node_id2_clip2, node_id3_0, numleafs;
//             public int face_id;
//             public int face_num;
//             public static int n_bytes = boundbox_t.n_bytes + vec3_t.n_bytes + 4 * 7;
//         }


//         public static class face_t
//         { 
//             [HideInInspector]
//             public ushort plane_id, side;                // 0 if in front of the plane, 1 if behind the plane
//             public int ledge_id;               // id to edge_t
//             public ushort ledge_num;           // number of edges in the List of edges
//             public ushort texinfo_id;          // id to surface_t 
//             public Byte typelight;            // type of lighting, for the face
//             public Byte baselight;            // from 0xFF (dark) to 0 (bright)
//             public Byte[] light;             // two additional LMData models  
//             public int lightmap;               // Pointer inside the general LMData map, or -1
//                                                // this define the start of the face LMData map
//             public int lightmap_index;

//             public static int n_bytes = 4 * sizeof(ushort) + 2*sizeof(int) + 4;

//             public 
//         }

        
//     // PARSE DATA
//     public mipheader_t ParseMipHeader(Byte[] byteArray, int offset)
//     {
//         mipheader_t mipheader = new mipheader_t();

//         int i = 0;
//         mipheader.numtex = toInt(byteArray, offset + i);
//         i += 4;
//         mipheader.offset = new int[mipheader.numtex];
//         for (int n_offset = 0;  n_offset < mipheader.numtex;n_offset++)
//         {
//             mipheader.offset[n_offset] = toInt(byteArray, offset + i);
//             i += 4;
//         }
//         mipheader.n_bytes = 4 + 4*mipheader.numtex;

//         return mipheader;
//     }
    
//     public miptex_t ParseMiptex(Byte[] byteArray, int offset)
//     {
//         miptex_t miptex = new miptex_t();
//         miptex.tex_offset = offset;
//         int i = 0;
//         miptex.name = new byte[16];
//         int N_CHARS = 0;
//         for (int n_char = 0; n_char < 16; n_char++)
//         {
//             if (byteArray[offset + n_char] == 0)
//             {
//                 break;
//             }
//             miptex.name[n_char] = byteArray[offset + n_char];
//             N_CHARS++;
//         }
//         i += 16;
//         miptex.nameStr = Encoding.UTF8.GetString(miptex.name).Substring(0,N_CHARS);
//         miptex.width = toUInt(byteArray, offset + i);
//         i += 4;
//         miptex.height = toUInt(byteArray, offset + i);
//         i += 4;
//         miptex.offset1 = toUInt(byteArray, offset + i);
//         i += 4;
//         miptex.offset2 = toUInt(byteArray, offset + i);
//         i += 4;
//         miptex.offset4 = toUInt(byteArray, offset + i);
//         i += 4;
//         miptex.offset8 = toUInt(byteArray, offset + i);

//         return miptex;
//     }

//     public miptex_t[] ParseTextures(Byte[] byteArray, int offset, int size, mipheader_t mipheader)
//     {
//         int n_mips = mipheader.numtex;
//         miptex_t[] miptexs = new miptex_t[n_mips];

//         int i = 0;
//         for (int n_mip = 0; n_mip < n_mips; n_mip++)
//         {
//             i = mipheader.offset[n_mip];
//             miptexs[n_mip] = ParseMiptex(byteArray, offset+i);
//          }

//         return miptexs;
//     }

//     public surface_t ParseSurface(Byte[] byteArray, int offset)
//     {
//         surface_t surface = new surface_t();

//         int i = 0;

//         surface.vectorS = ParseVec3(byteArray, offset + i);
//         i += vec3_t.n_bytes;
//         surface.distS = BitConverter.ToSingle(byteArray, offset + i);
//         i += sizeof(float);
//         surface.vectorT = ParseVec3(byteArray, offset + i);
//         i += vec3_t.n_bytes;
//         surface.distT = BitConverter.ToSingle(byteArray, offset + i);
//         i += sizeof(float);
//         surface.texture_id = toUInt(byteArray, offset + i);
//         i += sizeof(uint);
//         surface.animated = toUInt(byteArray, offset + i);


//         return surface;

//     }
    
//     public surface_t[] ParseTexInfos(Byte[] byteArray, int offset, int size)
//     {
//         int N_SURFS = size / surface_t.n_bytes;
//         surface_t[] surfaces = new surface_t[N_SURFS];

//         int i = 0;
//         for (int n_surf = 0; n_surf < N_SURFS; n_surf++)
//         {
//             surfaces[n_surf] = ParseSurface(byteArray, offset + i); ;
//             i += surface_t.n_bytes;
//         }

//         return surfaces;
//     }
    
//     public short[] ParseLstEdges(Byte[] byteArray, int offset, int size)
//     {
//         int N_LEDGES = size / 4;
//         short[] ledges = new short[N_LEDGES];

//         int i = 0;
//         for (int n_ledge = 0; n_ledge < N_LEDGES; n_ledge++)
//         {
//             ledges[n_ledge] = (short)toInt(byteArray, offset + i);
//             i += 4;
//         }

//         return ledges;
//     }

//     public ushort[] ParseLFaces(Byte[] byteArray, int offset, int size)
//     {
//         int N_LFACES = size / 2;
//         ushort[] lfaces = new ushort[N_LFACES];

//         int i = 0;
//         for (int n_lface = 0; n_lface < N_LFACES; n_lface++)
//         {
//             lfaces[n_lface] = toUShort(byteArray, offset + i);
//             i += 2;
//         }

//         return lfaces;
//     }

//     public edge_t ParseEdge(Byte[] byteArray, int offset)
//     {
//         int i = 0;
//         edge_t edge = new edge_t();
//         edge.vertex0 = toShort(byteArray, offset + i);
//         i += 2;
//         edge.vertex1 = toShort(byteArray, offset + i);

//         return edge;
//     }

//     public edge_t[] ParseEdges(Byte[] byteArray, int offset, int size)
//     {
//         int N_EDGES = size / edge_t.n_bytes;
//         edge_t[] faces = new edge_t[N_EDGES];

//         int i = 0;
//         for (int n_edge = 0; n_edge < N_EDGES; n_edge++)
//         {
//             faces[n_edge] = ParseEdge(byteArray, offset + i); ;
//             i += edge_t.n_bytes;
//         }

//         return faces;
//     }

//     public face_t ParseFace(Byte[] byteArray, int offset)
//     {
//         int i = 0;
//         face_t face = new face_t();
//         face.plane_id = toUShort(byteArray, offset + i);
//         i += 2;
//         face.side = toUShort(byteArray, offset + i);
//         i += 2;
//         face.ledge_id = toInt(byteArray, offset + i);
//         i += 4;
//         face.ledge_num = toUShort(byteArray, offset + i);
//         i += 2;
//         face.texinfo_id = toUShort(byteArray, offset + i);
//         i += 2;
//         face.typelight = byteArray[offset + i];
//         i += 1;
//         face.baselight = byteArray[offset + i];
//         i += 1;
//         face.light = new byte[2];
//         face.light[0] = byteArray[offset + i];
//         i += 1;
//         face.light[1] = byteArray[offset + i];
//         i += 1;
//         face.lightmap = toInt(byteArray, offset + i);

//         return face;
//     }

//     public face_t[] ParseFaces(Byte[] byteArray, int offset, int size)
//     {
//         int N_FACES = size / face_t.n_bytes;
//         face_t[] faces = new face_t[N_FACES];

//         int i = 0;
//         for (int n_face = 0; n_face < N_FACES; n_face++)
//         {
//             faces[n_face] = ParseFace(byteArray, offset + i); ;
//             i += face_t.n_bytes;
//         }

//         return faces;
//     }

//     public dheader_t ParseHeaders(Byte[] byteArray, int offset)
//     {
//         int N_LUMPS = 15;
//         dheader_t headers = new dheader_t();
//         headers.headers = new dentry_t[N_LUMPS];

//         int i_offset = offset;

//         for (int i = 0; i < N_LUMPS; i++)
//         {
//             headers.headers[i].offset = toInt(byteArray, i_offset);
//             i_offset += 4;
//             headers.headers[i].size = toInt(byteArray, i_offset);
//             i_offset += 4;
//         }

//         return headers;
//     }

//     public model_t ParseModel(Byte[] byteArray, int offset)
//     {
//         int i = 0;
//         model_t model = new model_t();
//         model.bound = ParseBoundBox(byteArray, offset + i);
//         i += boundbox_t.n_bytes;
//         model.origin = ParseVec3(byteArray, offset + i);
//         i += vec3_t.n_bytes;
//         model.node_id0_bsp = BitConverter.ToInt32(byteArray, offset + i);
//         i += 4;
//         model.node_id1_clip1 = BitConverter.ToInt32(byteArray, offset + i);
//         i += 4;
//         model.node_id2_clip2 = BitConverter.ToInt32(byteArray, offset + i);
//         i += 4;
//         model.node_id3_0 = BitConverter.ToInt32(byteArray, offset + i);
//         i += 4;
//         model.numleafs = BitConverter.ToInt32(byteArray, offset + i);
//         i += 4;
//         model.face_id = BitConverter.ToInt32(byteArray, offset + i);
//         i += 4;
//         model.face_num = BitConverter.ToInt32(byteArray, offset + i);

//         return model;
//     }
    
//     public model_t[] ParseModels(Byte[] byteArray, int MODELS_OFFSET, int N_MODELS)
//     {
//         model_t[] models = new model_t[N_MODELS];

//         int i = 0;
//         for (int n_model = 0; n_model < N_MODELS; n_model++)
//         {
//             models[n_model] = ParseModel(byteArray, MODELS_OFFSET + i); ;
//             i += model_t.n_bytes;

//             if (models[n_model].face_id > maxFaceId)
//             {
//                 maxFaceId = models[n_model].face_id;
//             }
//         }

//         return models;
//     }

//     public boundbox_t ParseBoundBox(Byte[] byteArray, int offset)
//     {
//         boundbox_t bound = new boundbox_t();
//         bound.min = ParseVec3(byteArray, offset);
//         bound.max = ParseVec3(byteArray, offset+vec3_t.n_bytes);
//         return bound;
//     }

//     public Vector3 ParseVec3(Byte[] byteArray, int offset)
//     {
//         Vector3 vec3 = new Vector3();
//         vec3.x = BitConverter.ToSingle(byteArray, offset);
//         vec3.y = BitConverter.ToSingle(byteArray, offset+4);
//         vec3.z = BitConverter.ToSingle(byteArray, offset+8);

//         return vec3;
//     }

//     public string ParseEntities(Byte[] byteArray, int ENTITIES_OFFSET, int ENTITIES_SIZE)
//     {
//         string entities = System.Text.Encoding.ASCII.GetString(byteArray, ENTITIES_OFFSET, ENTITIES_SIZE);
//         return entities;
//     }

//     public Vector3[] ParseVectices(Byte[] byteArray, int VERTS_OFFSET, int VERTS_SIZE)
//     {
//         int N_VERTS = VERTS_SIZE / vec3_t.n_bytes;
//         Vector3[] vertices = new Vector3[N_VERTS];

//         int i = 0;
//         for (int n_vert = 0;  n_vert < N_VERTS;n_vert++)
//         {
//             Vector3 vert = ParseVec3(byteArray, VERTS_OFFSET + i);
//             i += vec3_t.n_bytes;
//             vertices[n_vert] = vert;
//         }
        
//         return vertices; 
//     }


//     }



// }
